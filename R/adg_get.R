# WARNING - Generated by {fusen} from dev/flat_teaching.Rmd: do not edit by hand

#' Comprehensive Average Daily Gain (ADG) Calculation Pipeline
#'
#' @description
#' Integrated system for calculating porcine average daily gain (ADG) through 
#' cleaned weight data, incorporating growth curve modeling and prediction 
#' capabilities. Inherits and extends the functionality of [clean_weight_get()].
#'
#' @inheritParams clean_weight_get
#' 
#' @details
#' **Extended Processing Workflow**:
#' \enumerate{
#'   \item **Data Preparation**:
#'     \itemize{
#'       \item Inherits all cleaning steps from [clean_weight_get()]
#'       \item Additional outlier handling specific to growth modeling
#'     }
#'     
#'   \item **Growth Modeling**:
#'     \itemize{
#'       \item Polynomial regression fitting (degree configurable)
#'       \item Weight trajectory prediction with confidence intervals
#'       \item Dynamic range extension for forward/backward prediction
#'     }
#'     
#'   \item **ADG Calculation**:
#'     \itemize{
#'       \item Stage-specific growth rate computation
#'       \item Weight-to-time conversion modeling
#'       \item Prediction range optimization
#'     }
#' }
#'
#' **Modeling Features**:
#' \itemize{
#'   \item Dual prediction modes (linear/polynomial)
#'   \item Automatic outlier boundary detection
#'   \item Confidence interval calculation for predictions
#'   \item Multi-stage growth curve analysis
#' }
#'
#' @return Enhanced `list` containing:
#' \itemize{
#'   \item `adg_info`: 
#'     \itemize{
#'       \item Aggregated growth metrics data.table
#'       \item Contains columns:
#'         \itemize{
#'           \item `responder`, `location`, `stage`
#'           \item `start_date_cut`, `end_date_cut`
#'           \item `min_weight_cut`, `max_weight_cut`
#'           \item `lm_slope`, `r_squared`
#'           \item `stage_days`, `adg`
#'         }
#'     }
#'   \item `adg_data`:
#'     \itemize{
#'       \item Detailed prediction results data.table
#'       \item Contains columns:
#'         \itemize{
#'           \item All columns from `cleaned_data`
#'           \item `predicted_weight_lm`, `lower_lm`, `upper_lm`
#'           \item `outlier` (prediction status flag)
#'         }
#'     }
#' }
#'
#' @seealso
#' \itemize{
#'   \item [clean_weight_get()] For core data cleaning functionality
#'   \item [preprocess_data()] For input data preparation
#' }
#'
#' @importFrom data.table := .N .SD
#' @importFrom MASS rlm
#' @importFrom purrr map map2
#' @importFrom stats predict
#' @export
#' @examples
#' result_nedap <- preprocess_data(data = mintyr::nedap, station_type = "nedap", quiet = TRUE)
#' adg_result <- adg_get(result_nedap, my_break = c(30,120), quiet = TRUE)
#' head(adg_result$adg_info)
#' head(adg_result$adg_data)
adg_get <- function(data,
                    my_break,
                    range_offset = 0.5,
                    min_days = 35,
                    min_records = 20,
                    min_na_perc = 0.3,
                    w_threshold = 0.5,
                    maxit = 1000,
                    entry_weight_limit = 65,
                    exit_weight_limit = 85,
                    max_weight_limit = 15,
                    days_extend = 30,
                    step = 1,
                    degree = 2,
                    print_details = FALSE,
                    quiet = FALSE) {

  # Build configuration list
  config <- list(
    min_days = min_days,
    min_records = min_records,
    min_na_perc = min_na_perc,
    w_threshold = w_threshold,
    maxit = maxit,
    entry_weight_limit = entry_weight_limit,
    exit_weight_limit = exit_weight_limit,
    max_weight_limit = max_weight_limit,
    days_extend = days_extend,
    step = step,
    degree = degree
  )

  # Define process function based on quiet parameter
  process_fn <- if (quiet) {
    function(expr) suppressMessages(suppressWarnings(expr))
  } else {
    function(expr) expr
  }

  # Main processing logic wrapped in process_fn
  process_fn({
    tryCatch({
      validate_params(data, my_break, range_offset, config)

      # Clean weight data using clean_weight_get
      cleaned_data <- clean_weight_get(
        data = data,
        my_break = my_break,
        range_offset = range_offset,
        min_days = config$min_days,
        min_records = config$min_records,
        min_na_perc = config$min_na_perc,
        w_threshold = config$w_threshold,
        maxit = config$maxit,
        entry_weight_limit = config$entry_weight_limit,
        exit_weight_limit = config$exit_weight_limit,
        max_weight_limit = config$max_weight_limit,
        days_extend = config$days_extend,
        step = config$step,
        degree = config$degree,
        print_details = print_details,
        quiet = quiet
      )

      # Calculate ADG
      if (!is.null(cleaned_data)) {
        adg_results <- cleaned_data |>
          calculate_adg_and_clean_data(
            my_break = my_break,
            range_offset = range_offset,
            days_extend = config$days_extend,
            step = config$step,
            degree = config$degree
          )

        return(adg_results)
      } else {
        return(NULL)
      }

    }, error = function(e) {
      if (!quiet) {
        cli::cli_alert_danger("Error in adg_get: {e$message}")
      }
      return(NULL)
    }, warning = function(w) {
      if (!quiet) {
        cli::cli_alert_warning("Warning in adg_get: {w$message}")
      }
    })
  })
}
cut_weight <- function(data, my_break, range_offset) {
  rlm_predict <- NULL
  # Convert my_break to grams to match weight representation in data
  my_break <- my_break * 1000
  # Generate actual break points using the given range and offset
  actual_breaks <- c(my_break[1] - range_offset * 1000, my_break[2] + range_offset * 1000)
  # Select weights within the specified range
  data <- data[rlm_predict >= actual_breaks[1] & rlm_predict <= actual_breaks[2], ]
  # Add a 'stage' column to represent the selected weight range
  #data[, `:=`(stage, paste0(my_break[1] / 1000, "-", my_break[2] / 1000))]
  return(data)
}
process_lm_results <- function(data, my_break, range_offset, ...) {
  rlm_outliers <- . <- responder <- quiet_lm_result <- lm_slope <- NULL
  quiet_lm <- purrr::quietly(stats::lm)

  cut_data <- cut_weight(data = data, my_break = my_break, range_offset = range_offset)
  temp1 <- cut_data[!is.na(rlm_outliers) & rlm_outliers == FALSE]

  # 对每个 responder 的数据进行线性回归
  temp2 <- temp1[, .(data = list(.SD)), by = responder
  ][, `:=`(quiet_lm = purrr::map(data, \(df, ...) quiet_lm(..., data = df), ...))]

  # 修改这部分代码，使用 map 而不是 map_chr，并提供默认值
  temp2[, `:=`(
    quiet_lm_result = purrr::map(quiet_lm, "result"),
    messages = purrr::map(quiet_lm, \(x) if(is.null(x$messages)) "" else x$messages),
    warnings = purrr::map(quiet_lm, \(x) if(is.null(x$warnings)) "" else x$warnings)
  )]

  # 处理预测值、斜率和 R 平方
  temp2[, `:=`(
    lm_predict = purrr::map2(quiet_lm_result, warnings, \(x, w) {
      if (length(w) == 0 || w == "") try(stats::predict(x), silent = TRUE) else NA
    }),
    lm_slope = purrr::map(quiet_lm_result, \(x) {
      if (!is.null(x)) try(stats::coef(x)["seq_days"], silent = TRUE) else NA
    }),
    r_squared = purrr::map_dbl(quiet_lm_result, \(x) {
      if (!is.null(x)) try(summary(x)$r.squared, silent = TRUE) else NA
    })
  )]

  # 清理并扩展数据
  final <- temp2[, c("responder", "lm_slope", "r_squared")]
  final[, lm_slope := unlist(lm_slope)]

  return(final)
}
get_my_break_per_pig_lm <- function(data, my_break, range_offset, days_extend, step, degree) {
  seq_days <- predicted_weight_lm <- NULL
  # Convert to data.table if not already
  dt <- data.table::copy(data)
  cut_data <- cut_weight(data = dt, my_break = my_break, range_offset = range_offset)

  # Create safe lm function and fit model
  safelm <- purrr::safely(.f = stats::lm)

  # Fit polynomial regression using poly() with raw polynomials
  safe_model <- safelm(weight ~ poly(seq_days, degree = degree, raw = TRUE), data = cut_data)

  if (!is.null(safe_model$error)) {
    cli::cli_alert_danger("Model fitting failed: {safe_model$error$message}")
    stop(paste("Model fitting error:", safe_model$error$message))
  }

  model <- safe_model$result

  if (is.null(my_break)) {
    cli::cli_alert_danger("Missing required my_break parameter")
    stop("my_break parameter is required for dynamic prediction range")
  }

  # Set prediction range
  my_break_g <- my_break * 1000
  actual_breaks <- c(
    my_break_g[1] - range_offset * 1000,
    my_break_g[2] + range_offset * 1000
  )

  # Create prediction sequence
  date_range <- dt[, range(date)]
  days_range <- dt[, range(seq_days)]

  # Forward prediction
  forward_days <- seq(from = days_range[1], to = days_range[1] - days_extend, by = -step)
  forward_dt <- data.table::data.table(seq_days = forward_days)
  forward_pred <- predict(model, newdata = forward_dt)
  forward_cutoff <- which(forward_pred < actual_breaks[1])[1]
  if (!is.na(forward_cutoff)) {
    forward_days <- forward_days[1:forward_cutoff]
  }

  # Backward prediction
  backward_days <- seq(from = days_range[2], to = days_range[2] + days_extend, by = step)
  backward_dt <- data.table::data.table(seq_days = backward_days)
  backward_pred <- predict(model, newdata = backward_dt)
  backward_cutoff <- which(backward_pred > actual_breaks[2])[1]
  if (!is.na(backward_cutoff)) {
    backward_days <- backward_days[1:backward_cutoff]
  }

  # Merge prediction sequences
  pred_days <- sort(unique(c(forward_days, days_range[1]:days_range[2], backward_days)))
  new_dt <- data.table::data.table(seq_days = pred_days)

  # Safe prediction with confidence intervals
  safe_predict <- purrr::safely(.f = predict)
  pred_result <- safe_predict(
    model,
    newdata = new_dt,
    interval = "prediction"
  )

  if (!is.null(pred_result$error)) {
    cli::cli_alert_danger("Prediction calculation failed: {pred_result$error$message}")
    stop(paste("Prediction error:", pred_result$error$message))
  }

  # Create results data.table
  results <- data.table::data.table(
    seq_days = pred_days,
    predicted_weight_lm = pred_result$result[, "fit"],
    lower_lm = pred_result$result[, "lwr"],
    upper_lm = pred_result$result[, "upr"]
  )

  # Add date and R-squared columns
  results[, `:=`(
    date = date_range[1] + as.difftime(pred_days - days_range[1], units = "days"),
    r_squared_lm = summary(model)$r.squared
  )]

  # Filter results within prediction range
  results <- results[predicted_weight_lm >= actual_breaks[1] &
                       predicted_weight_lm <= actual_breaks[2]]

  return(results)
}
get_my_break_all_pigs <- function(data, my_break, range_offset, step, days_extend, degree) {
  . <- responder <- location <- rlm_outliers <- seq_days <- seq_in_day <- weight <- rlm_predict <- predicted_weight_lm <- NULL
  cli::cli_process_start("Processing all pig predictions")
  # Extract base information
  base_info <- unique(data[, .(responder, location)])

  # Handle outliers
  clean_data <- data[rlm_outliers == FALSE]

  # Extract basic information
  selected_data <- data[, .(
    responder,
    seq_days,
    location,
    date,
    seq_in_day,
    weight,
    rlm_predict,
    rlm_outliers
  )]

  # Initialize safe prediction function
  safe_predict <- function(data) {
    tryCatch({
      get_my_break_per_pig_lm(
        data = data,
        my_break = my_break,
        range_offset = range_offset,
        step = step,
        days_extend = days_extend,
        degree = degree
      )
    }, error = function(e) {
      cli::cli_alert_warning("Error processing data: {e$message}")
      return(NULL)
    })
  }

  # Linear model predictions
  cli::cli_progress_step("Predictions for each pig", spinner = TRUE)
  lm_results <- clean_data[, {
    model_result <- safe_predict(.SD)
  }, by = responder]
  cli::cli_process_done()

  lm_results <- merge(lm_results, base_info, by = "responder", all = TRUE)

  # Merge operations
  final_results <- merge(
    selected_data,
    lm_results,
    by = c("responder", "date", "seq_days", "location"),
    all = TRUE
  )

  final_results[, `:=`(
    weight = as.numeric(weight),
    predicted_weight_lm = as.numeric(predicted_weight_lm)
  )][, `:=`(
    weight = data.table::fcase(
      is.na(weight), predicted_weight_lm,
      default = weight
    ),
    outlier = data.table::fcase(
      rlm_outliers == FALSE & is.na(predicted_weight_lm), "bound",
      rlm_outliers == FALSE & !is.na(predicted_weight_lm), "normal",
      rlm_outliers == TRUE, "outliers",
      default = "predict"
    )
  )]

  # Sort by date
  data.table::setorder(final_results, date)

  cli::cli_alert_info("Processed {.field {length(unique(final_results$responder))}} pigs with {.field {nrow(final_results)}} total records")
  cli::cli_process_done()
  return(final_results)
  cli::cli_process_done()
}
extract_growth_metrics <- function(data, my_break) {
  predicted_weight_lm <- rlm_outliers <- seq_days <- NULL
  # Input validation
  data <- data.table::copy(data)

  # Filter data more efficiently
  data_predict_date <- data[!is.na(predicted_weight_lm)]
  data_true_cut <- data[
    !is.na(predicted_weight_lm) &
      !is.na(rlm_outliers) &
      rlm_outliers == FALSE
  ]

  # Extract min/max records more efficiently
  get_boundary_records <- function(dt) {
    min_seq <- dt[, min(seq_days)]
    max_seq <- dt[, max(seq_days)]
    list(
      min = dt[seq_days == min_seq],
      max = dt[seq_days == max_seq]
    )
  }

  predict_records <- get_boundary_records(data_predict_date)
  true_records <- get_boundary_records(data_true_cut)

  # Calculate stage days
  stage_days <- as.numeric(difftime(
    unique(predict_records$max$date),
    unique(predict_records$min$date),
    units = "days"
  ))

  # Validate stage days
  if (stage_days <= 0) {
    cli::cli_alert_warning("Invalid time period detected: {.field {cli::col_red(stage_days)}} days")
  }

  # Calculate ADG (weight difference in grams / days)
  weight_diff <- (my_break[2] - my_break[1]) * 1000
  adg <- weight_diff / stage_days

  # Create results directly as data.table
  results <- data.table::data.table(
    location = unique(data$location),
    min_weight_cut = mean(true_records$min$weight),
    max_weight_cut = mean(true_records$max$weight),
    start_date_cut = unique(true_records$min$date),
    end_date_cut = unique(true_records$max$date),
    stage_days = stage_days,
    adg = adg
  )

  # Validate results
  na_cols <- names(results)[results[, sapply(.SD, anyNA)]]
  if (length(na_cols) > 0) {
    cli::cli_alert_warning("Missing values detected in columns: {paste(na_cols, collapse = ', ')}")
  }

  return(results)
}
extract_growth_metrics_all <- function(data, my_break) {
  responder <- NULL
  # 对每个responder进行处理
  cli::cli_progress_step("Extraction ADG information for each pig", spinner = TRUE)
  results <- data[, {
    extract_growth_metrics(.SD, my_break)
  }, by = responder, showProgress=FALSE]  # 添加 .progress = FALSE
  cli::cli_process_done()

  return(results)
}
calculate_adg_and_clean_data <- function(data, my_break, range_offset, days_extend, step, degree) {
  location <- responder <- seq_days <- seq_in_day <- stage <- NULL
  # Create a deep copy of the input data
  data <- data.table::copy(data)

  # Calculate actual breaks once
  actual_breaks <- c(
    my_break[1] - range_offset,
    my_break[2] + range_offset
  )

  # Function to process data and handle errors
  process_data <- function() {
    cli::cli_h1("ADG Calculation")
    cli::cli_alert_info("Truncated weight from {.field {actual_breaks[1]}kg} to {.field {actual_breaks[2]}kg}")

    # Get all pigs data
    all_info <- get_my_break_all_pigs(
      data = data,
      my_break = my_break,
      range_offset = range_offset,
      days_extend = days_extend,
      step = step,
      degree = degree
    )
    data.table::setorder(all_info, location, responder, date, seq_days, seq_in_day)
    # Process linear model results
    adg_info2 <- process_lm_results(
      data = all_info,
      my_break = my_break,
      range_offset = range_offset,
      formula = weight ~ seq_days
    )

    # Extract growth metrics
    adg_info1 <- extract_growth_metrics_all(
      data = all_info,
      my_break = my_break
    )

    # Merge results and add stage column
    adg_info <- merge(adg_info1, adg_info2)
    adg_info[, stage := paste0(my_break[1], "-", my_break[2])]

    # Set column order
    col_order <- c(
      "responder", "location", "stage",
      "start_date_cut", "min_weight_cut",
      "end_date_cut", "max_weight_cut",
      "lm_slope", "r_squared",
      "stage_days", "adg"
    )
    data.table::setorder(adg_info, location, responder)
    data.table::setcolorder(adg_info, col_order)

    list(
      adg_info = adg_info,
      adg_data = all_info
    )
  }

  # Main execution with error handling
  tryCatch({
    result <- process_data()
    cli::cli_alert_success("ADG calculation completed successfully")
    return(result)
  },
  error = function(e) {
    cli::cli_alert_danger("Error occurred during ADG calculation")
    cli::cli_alert_info("Error details: {conditionMessage(e)}")
    stop("Execution stopped due to error: ", conditionMessage(e))
  },
  warning = function(w) {
    cli::cli_alert_warning("Warning during calculation: {conditionMessage(w)}")
    invokeRestart("muffleWarning")
  })
}
