# WARNING - Generated by {fusen} from dev/flat_teaching.Rmd: do not edit by hand

#' Plot Average Daily Feed Intake (ADFI) Curves
#'
#' @description
#' Creates and optionally saves visualization plots for pig feed intake data based on ADFI (Average Daily Feed Intake) 
#' calculations. The function generates detailed feed intake curve plots with original and corrected values, 
#' smoothing lines, and state indicators.
#'
#' @inheritParams adg_plot
#' @param data A list object returned by the `adfi_get()` function, containing ADFI data and related information.
#'
#' @return A `data.table` containing:
#' \itemize{
#'   \item `location`: Location identifier
#'   \item `data`: List of data for each location
#'   \item `plot`: List of ggplot2 objects for each location
#' }
#'
#' @details
#' The plots created by `adfi_plot` include:
#' \itemize{
#'   \item Original daily feed intake values (gray points)
#'   \item Corrected daily feed intake values (colored by state)
#'   \item LOESS smoothing line for corrected values
#'   \item Horizontal reference lines showing average corrected ADFI
#'   \item Text annotations showing original and corrected ADFI values
#' }
#'
#' @seealso
#' \code{\link{adfi_get}} for calculating ADFI data
#' \code{\link{adg_plot}} for plotting Average Daily Gain data
#'
#' @importFrom ggplot2 ggplot aes geom_point geom_line geom_smooth scale_y_continuous geom_hline 
#'   facet_wrap scale_x_date geom_text
#' @importFrom data.table copy :=
#' @importFrom purrr map map2
#'
#' @export
#' @examples
#' result_nedap <- preprocess_data(data = mintyr::nedap, station_type = "nedap", quiet = TRUE)
#' adg_result <- adg_get(result_nedap, my_break = c(30,120), quiet = TRUE)
#' adfi_result <- adfi_get(result_nedap, adg_result, quiet = TRUE)
#' res <- adfi_plot(data = adfi_result, save_path = tempdir(), location = "101", quiet = TRUE)
#' # Check exported files
#' list.files(path = tempdir(), pattern = "png", recursive = TRUE)
#' # Clean up exported files
#' files <- list.files(
#'   path = tempdir(),         # Default export directory
#'   pattern = "png",          # File type pattern to search
#'   recursive = TRUE,         # Search in subdirectories
#'   full.names = TRUE         # Return full file paths
#' )
#' file.remove(files)          # Remove all exported files
adfi_plot <- function(data,
                      responders = NULL,
                      locations = NULL,
                      color_theme = "d3",
                      save_path = NULL,
                      file_prefix = "loc",
                      file_suffix = NULL,
                      dpi = 300,
                      device = "png",
                      quiet = FALSE) {

  # 定义处理函数，根据quiet参数决定是否抑制消息和警告
  process_fn <- if (quiet) {
    function(expr) suppressMessages(suppressWarnings(expr))
  } else {
    function(expr) expr
  }

  # 使用process_fn包装主要处理逻辑
  result <- process_fn({
    # 创建ADFI图表
    adfi_results <- create_adfi_plots(
      data = data,
      responders = responders,
      locations = locations,
      color_theme = color_theme
    )

    # 如果提供了保存路径，则保存图表
    if (!is.null(save_path)) {
      save_plots(
        data = adfi_results,
        save_path = save_path,
        plot_type = "adfi",
        file_prefix = file_prefix,
        file_suffix = file_suffix,
        dpi = dpi,
        device = device
      )
    }

    # 返回结果
    adfi_results
  })
  
  return(result)
}

create_adfi_plots <- function(data, responders = NULL, locations = NULL, color_theme = "d3") {
  responder <- location <- . <- origin_dfi <- corrected_dfi <- mean_text <- state <- y_pos <- NULL
  # 验证颜色主题
  color_scale <- validate_color_theme(color_theme)

  # 验证输入并过滤数据
  validated <- validate_inputs(data, "adfi", responders, locations)
  data <- validated$data
  adfi_data <- validated$filtered_data

  # 处理信息数据
  current_info <- data$adfi_info
  if (!is.null(responders)) current_info <- current_info[responder %in% responders]

  # 准备标注数据
  text_data <- current_info[
    ,
    {
      target_data <- adfi_data[location == .BY$location, ]
      x_pos <- if (nrow(target_data) > 0) min(target_data$date) else as.Date(NA)
      .(
        mean_text = sprintf("Original ADFI: %.2f\nCorrected ADFI: %.2f", origin_dfi, corrected_dfi),
        x_pos = x_pos,
        y_pos = 6000
      )
    },
    by = .(responder, location)
  ]

  # 分组处理
  adfi_data <- adfi_data[, .(data = list(.SD)), by = location]

  # 生成图形
  adfi_data[, plot := purrr::map2(data, location, function(.x, .y) {
    current_text <- text_data[location == .y & responder %in% unique(.x$responder)]
    n_responders <- length(unique(.x$responder))

    base_plot <- ggplot2::ggplot(.x, ggplot2::aes(x = date)) +
      ggplot2::geom_point(ggplot2::aes(y = origin_dfi), size = 1, color = "#666666") +
      ggplot2::geom_line(ggplot2::aes(y = corrected_dfi), linewidth = 0.3, alpha = 0.3) +
      ggplot2::geom_point(ggplot2::aes(y = corrected_dfi, color = state), size = 1) +
      ggplot2::geom_smooth(
        ggplot2::aes(y = corrected_dfi, color = "smooth line"),
        method = "loess", formula = y ~ x,
        linewidth = 0.2, alpha = 0.2
      ) +
      ggplot2::scale_y_continuous(breaks = seq(0, 6000, 1000), limits = c(0, 6000)) +
      ggplot2::geom_hline(
        data = current_info[responder %in% unique(.x$responder)],
        ggplot2::aes(yintercept = corrected_dfi),
        color = "gray", linewidth = 0.3, alpha = 0.3
      ) +
      ggplot2::facet_wrap(~ responder, ncol = min(2, n_responders)) +
      ggplot2::scale_x_date(date_breaks = "2 day", date_labels = "%m-%d")

    annotated_plot <- set_common_theme(
      base_plot,
      title = paste("Location:", .y),
      y_lab = "Average Daily Feed Intake (g)",
      color_scale = color_scale,
      legend_breaks = c("org", "corr", "elrp", "lll", "smooth line"),
      legend_labels = c("original adfi", "corrected adfi", "linear prediction", "linear interpolation", "smooth line")
    )

    annotated_plot +
      ggplot2::geom_text(
        data = current_text,
        ggplot2::aes(x = x_pos, y = y_pos, label = mean_text),
        hjust = 0, vjust = 1, size = 3.3, inherit.aes = FALSE
      )
  })]

  cli::cli_alert_success("Successfully created {.field {nrow(adfi_data)}} plot{?s}")
  return(adfi_data)
}
